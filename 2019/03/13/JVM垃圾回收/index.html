<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Wang Hao" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        JVM垃圾回收｜undefined
        
    </title>

    <link rel="canonical" href="http://wanghaocn.coding.me/me/2019/03/13/JVM垃圾回收/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/me/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/me/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/me/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('')
    }
</style>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost="true" data-istags="false
" data-ishome="false">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/me/">
                <span class="brand-logo">
                    Wang Hao
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/me/">Home</a>
                    </li>
					
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img" src="undefinedhttps://raw.githubusercontent.com/zhenlanghuo/zhenlanghuo.github.io/master/image/pexels-photo-251225_1080_c.jpg">


<style>
    
    header.intro-header {
        background-image: url('https://raw.githubusercontent.com/zhenlanghuo/zhenlanghuo.github.io/master/image/pexels-photo-251225_1080_c.jpgundefined')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>JVM垃圾回收</h1>
                    
                    <span class="meta">
                         作者 Wang Hao
                        <span>
                          日期 2019-03-13
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            JVM垃圾回收
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <p>首先，垃圾回收器是垃圾收集算法的具体实现。在这里先介绍一下集中垃圾回收4种算法及其原理和优缺点。</p>
<h6 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h6><h3 id="标记-清除算法（Mark-Sweep）："><a href="#标记-清除算法（Mark-Sweep）：" class="headerlink" title="标记-清除算法（Mark-Sweep）："></a>标记-清除算法（Mark-Sweep）：</h3><p>首先，对将要回收的对象进行标记工作，标记出所有要被回收的对象。然后统一回收被标记的对象。</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1.标记与清除的效率都不是很高。 2.清除后产生大量的内存碎片，空间碎片太多会导致在分配大对象时无法找到足够大的连续内存，从而不得不触发另一次垃圾回收动作。</p>
<h3 id="复制算法（Copying）："><a href="#复制算法（Copying）：" class="headerlink" title="复制算法（Copying）："></a>复制算法（Copying）：</h3><p>将内存按照容量分成大小相等的两块，每次只使用其中的一块。<br>当这一块内存用完了，就将还存活的对象复制到另一块上，再将已经使用过的内存空间一次性清理掉。<br>商用虚拟机都采用这种算法回收新生代的对象。因为新生代的对象每次回收都基本上只有 10% 左右的对象存活，需要复制的对象少，效率高。<br>优点：对整个半区进行内存回收，效率高，不会产生内存碎片<br>缺点：<br>1.需要提前预留内存空间，存在一定的内存浪费。<br>2.存活的对象比较多时，需要复制的对象较多，效率会比较低。</p>
<h3 id="标记-整理算法（Marking-Compact）："><a href="#标记-整理算法（Marking-Compact）：" class="headerlink" title="标记-整理算法（Marking-Compact）："></a>标记-整理算法（Marking-Compact）：</h3><p>将所有的存活的对象向内存的一段移动，直接清除掉边界以外的内存。<br>优点：<br>消除了标记清除中内存分散与碎片的问题，也消除了复制算法中内存减半的代价。<br>缺点：<br>效率低下，需要标记存活的对象，还需要标记存活对象的引用地址。效率上低于复制算法。</p>
<h3 id="分代收集算法（Gennerational-Collection）："><a href="#分代收集算法（Gennerational-Collection）：" class="headerlink" title="分代收集算法（Gennerational Collection）："></a>分代收集算法（Gennerational Collection）：</h3><p>根据对象的生命周期的不同，将内存划分为不同的几块，对不同周期的对象进行不同的收集算法。<br>新生代：每次回收的时候都会有大量的对象被收集，采用复制算法。<br>老年代：对象存活率高，采用标记清理或者标记整理算法进行收集。</p>
<h6 id="7种垃圾回收器："><a href="#7种垃圾回收器：" class="headerlink" title="7种垃圾回收器："></a>7种垃圾回收器：</h6><p>“如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实践”。<br>首先，聊一下并行与并发。<br><strong><em>并行（Parallel）</em></strong>：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<br><strong><em>并发（Concurrent）</em></strong>：指用户线程与垃圾回收线程同时执行（但是不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序在另一个CPU上。<br><strong><em>吞吐量（Throughput）</em></strong>：吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p>
<h3 id="Minor-GC与Full-GC："><a href="#Minor-GC与Full-GC：" class="headerlink" title="Minor GC与Full GC："></a>Minor GC与Full GC：</h3><p>新生代GC（Minor GC）：指发生在新生代的垃圾收集操作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC发生的特别频发，一般回收的速度也是特别快。<br>老年代GC（Major GC与Full GC）：指发生在老年代的GC操作，出现了Major GC，经常伴随着至少一次的Minor GC（但不是绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<h3 id="新生代收集器："><a href="#新生代收集器：" class="headerlink" title="新生代收集器："></a>新生代收集器：</h3><h2 id="Serial收集器："><a href="#Serial收集器：" class="headerlink" title="Serial收集器："></a>Serial收集器：</h2><p>Serial（串行）收集器，是最基本的发展历史最为悠久的收集器。是采用复制算法的新生代收集器。在JDK1.3.1之前，是新生代垃圾收集器的唯一选择。它是一个单线程收集器，只会使用一个CPU或者是一个收集线程去完成收集操作。！！！比较重要的是Serial垃圾收集器在进行工作的时候，必须暂停其他工作线程，直到收集工作完成之后才会恢复工作线程的使用（Stop The World）。这项工作是虚拟机在后台进行发起和自动完成的，在用户不可见的情况下，把用户的正常工作的线程停掉，对用户来说是很难接受的。<br>直到现在为止，Serial收集器仍然是HotSpot虚拟机Client模式下默认的新生代收集器。Serial收集器相对于其他垃圾收集器也有比较优秀的地方，简单而高效（与其他收集器的单线程相比）。对限定单个CPU的运行环境中，Serial收集器没有线程交互的开销，专心做垃圾收集自然可以获取更高的线程收集效率。</p>
<h2 id="ParNew收集器："><a href="#ParNew收集器：" class="headerlink" title="ParNew收集器："></a>ParNew收集器：</h2><p>ParNew收集器是Serial收集器的单线程版本。他也是一个新生代收集器。除了使用多线程进行垃圾收集之外，其余行为包括Serial的所有可用参数，收集算法，Stop The World，对象分配原则，回收策略等与Serial收集器完全相同。但是ParNew收集器却是许多运行在Server模式下的虚拟机的新生代首选的垃圾收集器。！！！除了Serial收集器之外，只有ParNew收集器能和CMS（Current Mark Sweep）收集器配合工作。<br>ParNew收集器在单CPU环境下，绝对不会有比Serial收集器更为优秀的表现，由于存在线程交互的开销，ParNew收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。<br>在多CPU环境下，随着CPU的增加，ParNew收集器对于CPU资源的利用是很有好处的。ParNew收集器默认开启的线程数，与CPU数相同，可以通过-XX:ParallerGCThreads进行设置。</p>
<h2 id="Parallel-Scavenge收集器："><a href="#Parallel-Scavenge收集器：" class="headerlink" title="Parallel Scavenge收集器："></a>Parallel Scavenge收集器：</h2><p>Parallel Scavenge收集器也是一个并行的多线程新生代收集器，也是使用复制算法。Parallel Scavenge收集器于其他收集器不同，CMS收集器关注的是尽可能短的缩短用户线程的停顿时间，而Parallel Scavenge收集器的关注点是达到一个可控制的吞吐率（Throughput）。<br>停顿时间越短越是有利于用户交互比较多的应用，良好的响应速度有助于提升用户体验。而高吞吐率有助于高效的利用CPU时间，主要用于后台运算而不需要太多的用户交互的操作。Parallel Scavenge提供了一个参数，-XX:+UseAdaptiveSizePolicy,这是一个开关参数，打开了之后，就不要手动的指定新生代的大小（-Xmn），和Eden、Survivor的比例（-XX:ServivorRatio）,晋升老年代对象年龄参数（-XX:PretengureSizeThrehold）等细节参数了。虚拟机会根据当前的运行情况收集性能监控信息，来动态的控制这些参数来控制合适的停顿时间或者最大的吞吐量，这种方式称为“GC的自适应调节策略（GC Ergonomics）”。自适应策略也是Parallel Scavenge收集器与ParNew收集器的一个重要的区别。</p>
<h3 id="老年代收集器："><a href="#老年代收集器：" class="headerlink" title="老年代收集器："></a>老年代收集器：</h3><h2 id="Serial-Old收集器："><a href="#Serial-Old收集器：" class="headerlink" title="Serial Old收集器："></a>Serial Old收集器：</h2><p>Serial Old收集器是Serial收集器的老年代版本。它是一个单线程收集器，使用“标记-整理算法（Mark-Compact）”。比较合适用于Client模式下的虚拟机使用。<br>在JDK1.5版本以前的版本（在Parallel Old出现之前），与Parallel Scavenge收集器连用<br>作为CMS收集器的备选方案，在并发收集发生Concurrent Mode Failure时使用</p>
<h2 id="Parallel-Old收集器："><a href="#Parallel-Old收集器：" class="headerlink" title="Parallel Old收集器："></a>Parallel Old收集器：</h2><p>Parallel Old时Parallel收集器的老年代版本，使用多线程和“标记-整理算法（Mark-Compact）”，这个收集器在JDK1.6版本之后投入之用。在此之前，如果新生代采用了Parallel Scavenge收集器，老年代除了使用Serial Old没有其他选择。在Parallel Old出现之后，Parallel Scavenge（吞吐率优先）有了名副其实的组合。在注重吞吐量和CPU资源敏感的场合，都可以使用Parallel Scavenge和Parallel Old组合。</p>
<h2 id="CMS收集器："><a href="#CMS收集器：" class="headerlink" title="CMS收集器："></a>CMS收集器：</h2><p>CMS（Concurrent Mark Sweep）收集器，是一种获取最短停顿时间的收集器。非常符合B/S架构的Java应用，这种服务非常重视服务的响应时间额速度。使用“标记-清除算法（Mark-Sweep）”实现。<br>工作流程分为4个步骤：<br>1.初始标记（CMS initial Mark）：仅仅只是标记一下GC Roots能够关联到的对象，时间很快，需要Stop The World<br>2.并发标记（CMS concurrent mark）：进行GC Tracing Mark过程，这整个过程是最长的。<br>3.重新标记（CMS remark）：为了修正并发标记期间，由于用户操作导致的标记产生变动的一部分标记对象记录，这个阶段会比初始标记稍微长一些，但是远比并发标记短。这个阶段也需要Stop The World。<br>4.并发清除（CMS concurrent sweep）<br>从整体来看，耗时最长的并发标记和并发清除线程都可以和用户线程一起工作，所以可以说CMS收集器的内存回收过程是与用户线程一起并发执行的。<br><strong><em>优点</em></strong>：CMS是一款比较优秀的GC收集器，并发收集，低停顿。也被称为“并发低停顿处理器（Concurrent Low Pause Collector）”。<br><strong><em>缺点</em></strong>：<br>1.对CPU资源非常敏感，面向并发的程序对CPU资源都是比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是在运行阶段，会占用一部分CPU资源，导致整个应用程序变慢。总吞吐量会降低。CMS默认的回收线程数是（CPU数量+3）/4。并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。<br>2.无法处理浮动垃圾（Floating Garbage）：可能会出现Concurrent Mode Failure，失败而导致另一次的Full GC产生。由于CMS并发清理阶段用户线程还在运行着，伴随着程序运行程序肯定还会有新的垃圾不断产生。只能等待下一个GC周期才能被收集。<br>3.标记-清除算法导致的内存碎片：CMS是一款基于“标记-清除算法”的垃圾收集器，这意味着收集结束之后会有大量的空间碎片产生。</p>
<h2 id="G1收集器（Garbage-First）："><a href="#G1收集器（Garbage-First）：" class="headerlink" title="G1收集器（Garbage First）："></a>G1收集器（Garbage First）：</h2><p>G1收集器是当今垃圾收集器发展最为前沿的成果之一，它是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是在未来可以替换掉JDK1.5中的CMS收集器。<br><strong><em>特点</em></strong>：<br>1.并行与并发：G1收集器可以充分的利用多CPU，多核条件下的硬件优势，使用多个CPU来充分的缩短Stop The World停顿时间。<br>2.分代收集：分代概念在G1收集器中依然得以保留。G1收集器可以采用不同的方式去处理新创建的对象和存活了一定时间，熬过了多次GC的就对象来获取更好的收集效果。<br>3.空间整合：G1收集器从整体上来看，是基于“标记-整理算法”实现的收集器。从局部来看，是基于“复制算法”实现的。这意味着G1运行期间不会产生内存碎片，G1收集器能够提供规整的可用内存。此特性有利于程序的长时间运行，也可以避免在分配了大对象无法找到内存空间的情况。<br>4.可预测的停顿：降低停顿时间是G1与CMS的共同关注点，但是G1除了降低停顿之外，还可以建立可以预测的停顿时间模型。能让使用者“明确指定”一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒，这已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p><strong><em>横跨整个堆内存</em></strong>：G1收集器将整个Java堆划分为多个大小相等的独立区域（Region）。虽然还保留了新生代和老年代的概念，但是新生代和老年代不是物理隔离的了，而是一部分（Region）的集合（不是必须连续的）。<br><strong><em>建立可预测的时间集合</em></strong>：G1收集器可以有计划的避免在整个Java堆中进行全区域的垃圾回收。G1会跟踪每一个Region中的垃圾堆积的价值大小（回收所得到的空间大小以及回收所需要的经验值），并在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值较大的Region。保证了G1可以在有限的时间范围内，获得尽可能高的收集效率。<br><strong><em>避免全堆扫描（Remembered Set）</em></strong>：G1把Java堆分成多个Region，就是化零为整。但是Region不可能是独立的，一个对象分配在某一个Region中，可以与整个Java堆的任意一个对象发生引用关系。在做可达性分析进行对象的检活的时候，需要扫描整个Java堆才能保证其准确性，这是对GC效率的极大损害。为了避免全堆扫描的发生，虚拟机为G1中的每一个Region堆都维护了一个与之对应的“Rememberes Set”。虚拟机发现在对Reference类型的对象进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference所引用的对象知否处于不同的Region中（在分代收集中，就是检查是否老年代中的对象引用了新生代的对象），如果是，那么就使用CardTable把相关引用信息记录到引用对象所属的Region中的Remembered Set中。在进行垃圾回收的时候，GC Roots中加入Remembered Set中即可保证不对全堆进行扫面也可以保证不会有遗漏。</p>
<p>如果不计算Remembered Set的执行过程，G1的工作流程大致可以分为以下几个流程：<br>1.初始标记（Initial Marking）：仅仅标记一下GC Roots所能关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，确保下一阶段用户程序并发运行时，能在正确的Region中创建对象，此阶段需要Stop The World，但是停顿时间很短。<br>2.并发标记（Concurrent Marking）：从GC Roots中，开始对堆中的对象开始进行可达性分析，找到存活的对象，这个阶段耗时比较长，但是可以与用户线程间并行执行。<br>3.最终标记（Final Marking）：为了修正在并发标记期间的用户线程执行所产生的变动，虚拟机在并发标记期间，将对象变化记录在Remembered Set Logs中，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要Stop The World，但是可以与用户线程并发执行。<br>4.筛选回收（Live Data Counting And Evacuation）：对所有Region中的回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划，此阶段也可以做到与用户线程并发执行，但是因为只会回收一部分Region，时间是用户可控制的，而且停顿用户线程可以大幅提高收集效率。</p>

                <hr>
                

                <ul class="pager">
                    
                    
                    <li class="next">
                        <a href="/me/2019/03/05/设计模式-6大设计原则/" data-toggle="tooltip" data-placement="top" title="设计模式-6大设计原则">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-6"><a class="toc-link" href="#垃圾收集算法"><span class="toc-text">垃圾收集算法</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-清除算法（Mark-Sweep）："><span class="toc-text">标记-清除算法（Mark-Sweep）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缺点："><span class="toc-text">缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法（Copying）："><span class="toc-text">复制算法（Copying）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标记-整理算法（Marking-Compact）："><span class="toc-text">标记-整理算法（Marking-Compact）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集算法（Gennerational-Collection）："><span class="toc-text">分代收集算法（Gennerational Collection）：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#7种垃圾回收器："><span class="toc-text">7种垃圾回收器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC与Full-GC："><span class="toc-text">Minor GC与Full GC：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新生代收集器："><span class="toc-text">新生代收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serial收集器："><span class="toc-text">Serial收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParNew收集器："><span class="toc-text">ParNew收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-Scavenge收集器："><span class="toc-text">Parallel Scavenge收集器：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#老年代收集器："><span class="toc-text">老年代收集器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Serial-Old收集器："><span class="toc-text">Serial Old收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parallel-Old收集器："><span class="toc-text">Parallel Old收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMS收集器："><span class="toc-text">CMS收集器：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#G1收集器（Garbage-First）："><span class="toc-text">G1收集器（Garbage First）：</span></a>
                </li></div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Wang Hao 2019
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/me/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/me/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/me/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://wanghaocn.coding.me/me/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="">
</body>

</html>
