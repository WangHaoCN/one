<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    
    <title>JUC专题-生产者/消费者问题 | Wang Hao</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
      <link rel="icon" href="/me/favicon.png">
    

    <link rel="stylesheet" href="/me/css/style.css">

    <link rel="stylesheet" href="/me/js/google-code-prettify/tomorrow-night-eighties.min.css">

  </head>

  <body>
</body></html>
<header>
	<a id="logo" href="/" title="Wang Hao">
	<img src="/me/favicon.png" alt="Wang Hao"></a>
	
	
		<!--搜索栏-->
		<i class="js-toggle-search iconfont icon-search"></i>


<form class="js-search search-form search-form--modal" method="get" action="http://gushi.li" role="search">
	<div class="search-form__inner">
		<div>
			<i class="iconfont icon-search"></i>
			<input class="text-input" placeholder="Enter Key..." type="search">
		</div>
	</div>
</form>
	

	
		<!--侧边导航栏-->
		<a id="nav-toggle" href="#"><span></span></a>

<nav>
	<div class="menu-top-container">
		<ul id="menu-top" class="menu">
			
				
				<li class="current-menu-item">
					<a href="http://weibo.com/" target="_blank">Weibo</a>
				</li>
			
		</ul>
	</div>
</nav>
	

</header>
<div class="m-header ">
	<section id="hero1" class="hero">
		<div class="inner">
		</div>
	</section>
	
		<figure class="top-image" data-enable="true"></figure>
	
</div>

<!--文章列表-->
<div class="wrapper">
  
    <!--文章-->
<article>
	
  
    <h1 class="post-title" itemprop="name">
      JUC专题-生产者/消费者问题
    </h1>
  

	<div class="post-body mb">
		<h1 id="JUC专题-生产者-消费者问题"><a href="#JUC专题-生产者-消费者问题" class="headerlink" title="JUC专题-生产者/消费者问题"></a>JUC专题-生产者/消费者问题</h1><blockquote>
<p>所谓生产者-消费者问题，实际上主要包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域。生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。</p>
</blockquote>
<p>共享数据区域中应该具备这样的线程间并发协作的功能：</p>
<ul>
<li>如果共享数据区已满的情况下，阻塞生产者继续生产数据置入</li>
<li>如果共享数据区为空的情况下，阻塞消费者继续消费数据</li>
</ul>
<p>实现生产者消费者问题，主要可以采用以下三种方式：</p>
<ul>
<li>基于Object类的wait/notify的消息通知机制</li>
<li>基于Lock的Condition的await/signal机制</li>
<li>使用BlockingQueue实现</li>
</ul>
<h2 id="wait-notify-消息通知机制"><a href="#wait-notify-消息通知机制" class="headerlink" title="wait/notify 消息通知机制"></a>wait/notify 消息通知机制</h2><p>在java中，可以使用Object类的wait，notify或者notifyAll方法实现线程之间的通信。</p>
<h4 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h4><p>该方法，用来将当前线程置入休眠状态，知道接到通知或者被中断为止。在调用wait方法之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法和同步代码块中调用wait方法。调用wait方法之后，当前线程会释放锁。如果调用wait方法时，当前线程没有获得锁的情况下，会抛出<strong>IllegalMonitorStateException</strong>异常。如果再次获得锁的话，当前线程才会从wait方法处成功返回。</p>
<h4 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h4><p>该方法也只能在同步方法或同步代码块中使用，在调用前，线程也必须获得对象级别的锁。如果调用notify的时候，没有持有适当的锁，也会抛出<strong>IllegalMonitorStateException</strong>异常。该方法任意从<strong>WAITTING</strong>状态中的线程选取一个进行通知。使得调用等待方法的线程能从等待队列移入到同步队列中，等待有机会再一次获得到锁，从而使得wait方法处的线程能够从wait方法处退出。调用notify之后，线程不会立即释放对象锁，要等到程序退出同步代码块的时候，才会释放对象锁。</p>
<h4 id="notifyAll方法"><a href="#notifyAll方法" class="headerlink" title="notifyAll方法"></a>notifyAll方法</h4><p>该方法与notify方法的工作模式相同，重要的一点差异，notify方法使之前在该对象上wait的线程统统退出<strong>WAITING</strong>状态，使得他们全部从等待队列移入到同步队列中去，等待下一次能够有机会获得对象监视器锁。</p>
<h3 id="wait-notify-存在的一些潜在的问题"><a href="#wait-notify-存在的一些潜在的问题" class="headerlink" title="wait/notify 存在的一些潜在的问题"></a>wait/notify 存在的一些潜在的问题</h3><ul>
<li><p>notify存在通知遗漏问题</p>
<p>TheadA没有开始wait的时候，TheadB已经开始notify了。这种情况下，TheadB的notify，是没有任何响应的。当ThreadB退出同步代码块之后，ThreadA开始wait状态，就会一直阻塞等待，知道被别的线程打断。</p>
<p>一般面对这个问题，我们会添加一个状态标志，让WaitThread调用wait方法前，先判断状态时候已经改变了没，如果通知早已发出，WaitThread就不再去wait。</p>
</li>
<li><p>等待wait的条件发生变化</p>
<p>线程在等待的时候接受了通知，但是之后等待的条件发生了变化，并没有再次对等待条件进行判断，也会产生错误。</p>
<p>在使用线程的等待通知机制的时候，一般都要在while循环中调用wait方法，需要同步使用一个boolean变量，</p>
</li>
<li><p>“假死”状态</p>
<p>如果是多消费者或多生产者，如果使用notify方法可能会出现假死情况，即唤醒的是同类线程。</p>
<p>假设当前多个消费者线程会调用wait方法阻塞等待，当其中的生产者线程获取到对象锁之后，调用notify，唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。</p>
<p>解决方案：将notify换成notifyAll，如果是使用lock的话，就将signal换成signalAll。</p>
</li>
</ul>
<h3 id="wait-notify-总结"><a href="#wait-notify-总结" class="headerlink" title="wait/notify 总结"></a>wait/notify 总结</h3><ul>
<li>永远在while中对条件进行判断，而不是if语句中对wait进行判断。</li>
<li>使用notify而不是notifyAll</li>
</ul>
<h2 id="Lock中Condition的await-signalAll"><a href="#Lock中Condition的await-signalAll" class="headerlink" title="Lock中Condition的await/signalAll"></a>Lock中Condition的await/signalAll</h2><h3 id="Condition简介"><a href="#Condition简介" class="headerlink" title="Condition简介"></a>Condition简介</h3><ul>
<li>Object的wait和notify/notifyAll是与对象监视器配合完成线程间的等待通知机制，是java底层级别的。</li>
<li>Condition和Lock配合实现实现等待/通知机制是语言级别的，具有更高的可控性和可扩展性。</li>
<li>Condition相对于Object等待通知机制的优点：<ul>
<li>Condition能够支持不响应中断，而通过使用Object方法不支持。</li>
<li>Condition能够支持多个等待队列，而Object方法只能支持一个。</li>
<li>Condition能够支持多个等待时间的设置，Object不支持。</li>
</ul>
</li>
</ul>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><p>针对于Object的wait方法，Condition提供了await、awaitNanos、awaitUntil方法。</p>
<ul>
<li>await方法：当前线程进入等待状态，如果其他线程调用Condition的signal或者signalAll方法，并且当前线程获取Lock从await方法返回。如果在等待状态中被中断，会抛出InterruptedException异常。</li>
<li>awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时。</li>
<li>await(long time, TimeUnit unit)throws InterruptedException：同awaitNanos，支持自定义时间单位。</li>
<li>awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间。</li>
</ul>
<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><ul>
<li>signal：唤醒一个等待在Condition上的线程，将该线程从等待队列转移到同步队列中，如果在同步队列中如果能竞争到Lock，则可以从等待方法中返回。</li>
<li>signalAll：唤醒所有等待在Condition上的线程。</li>
</ul>
<h2 id="使用BlockingQueue实现生产者-消费者"><a href="#使用BlockingQueue实现生产者-消费者" class="headerlink" title="使用BlockingQueue实现生产者-消费者"></a>使用BlockingQueue实现生产者-消费者</h2><p>BlockingQueue内部实现附加了两个阻塞操作。当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满。队列为空时，阻塞从队列中消费的线程，直至队列非空。</p>
<p>常用的BlockingQueue：</p>
<ul>
<li>ArrayBlockingQueue：是数组实现的有届阻塞队列。该队列命令元素先进先出(FIFO)。当队列满时，阻塞写入线程；当队列为空时，阻塞读取线程。</li>
<li>LinkedBlockingQueue：是用链表实现的有界阻塞队列，同样符合FIFO策略。</li>
<li>PriorityBlockingQueue：支持优先级的无界阻塞队列。</li>
<li>SynchronousQueue：每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。</li>
<li>LinkedTransferQueue：LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：LinkedBlockingDeque是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为Integer.MAX_VALUE。与LinkedBlockingQueue相比，主要的不同点在于，LinkedBlockingDeque具有双端队列的特性。</li>
<li>DelayQueue：DelayQueue是一个存放实现Delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。</li>
</ul>

	</div>
	<div class="meta split">
		
			<span>本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次</span>
		
		<time class="post-date" datetime="2020-01-02T09:05:58.000Z" itemprop="datePublished">2020-01-02</time>
	</div>
</article>

<!--评论-->

	
<div class="ds-thread" data-thread-key="JUC专题-生产者-消费者问题" data-title="JUC专题-生产者/消费者问题" data-url="http://wanghaocn.coding.me/me/2020/01/02/JUC专题-生产者-消费者问题/"></div>
<script type="text/javascript">

var duoshuoQuery = {short_name:"yumemor"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


  
</div>


  <svg id="bigTriangleColor" width="100%" height="40" viewbox="0 0 100 102" preserveaspectratio="none">
    <path d="M0 0 L50 100 L100 0 Z"/>
  </svg>

  


  <div class="wrapper"></div>





<div class="fat-footer">
	<div class="wrapper">
		<div class="layout layout--center">
			<div class="layout__item palm-mb">
				<div class="media">
					<img class="headimg" src="https://imgchr.github.la/steve.jpeg" alt="Wang Hao">
					<div class="media__body">
						<h4>justpsvm</h4>
						<p class="site-description">Stay Hungry,Stay Foolish.</p>
					</div>
				</div>
				<div class="author-contact">
					<ul>
						
							
							<li>
				        		<a href="http://weibo.com/" target="_blank">
				        			
				        				<i class="iconfont icon-weibo"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="https://github.com/" target="_blank">
				        			
				        				<i class="iconfont icon-github"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="https://www.zhihu.com/" target="_blank">
				        			
										<i class="iconfont icon-zhihu"></i>
				        			
				        		</a>
				        	</li>
						
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer" role="contentinfo">
	<div class="wrapper wrapper--wide split split--responsive">
		
			<span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次</span>
		
		<span>Theme by <a href="http://github.com/justpsvm">justpsvm</a>. Powered by <a href="http://hexo.io">Hexo</a></span>
	</div>
</footer>

	<!-－这里导入了 lib.js 里面涵盖了 jQuery 等框架 所以注释掉-->
	<!--<script src="http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js"></script>-->
	<script src="/me/js/lib.js"></script>
	<script src="/me/js/google-code-prettify/prettify.js"></script>
	<script src="/me/js/module.js"></script>
	<script src="/me/js/script.js"></script>
	
		<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	<script type="text/javascript">
		//代码高亮
		$(document).ready(function(){
	 		$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   			prettyPrint();
		});
	</script>
	

